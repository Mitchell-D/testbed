"""
High-level method for plotting ensembles of state and residual magnitude
and error from a directory of extracted subgrids with predictions, which
should have been generated by eval_subgrid_samples.py
"""
import numpy as np
import pickle as pkl
from datetime import datetime
from pathlib import Path
import matplotlib
import matplotlib.pyplot as plt
import h5py
from multiprocessing import Pool
from pprint import pprint as ppt

import generators
from eval_grids import parse_grid_params

def plot_state_and_res_mag_and_error():
    return

def plot_quad_sequence(
        pred_array, fig_path=None, true_array=None, pred_coarseness=1,
        plot_spec={}, show=False):
    """
    Plot a series of true and predicted sequences in a 4-panel plot,
    each panel containing the data from a single feature

    :@param true_array:(N,S,4) shaped array with N sequence samples, each of
        length S and having 4 features corresponding to feat_labels
    :@param pred_array:(N,S,4) shaped array with N sequence samples, each of
        length S and having 4 features corresponding to feat_labels
    """
    if not true_array is None:
        assert true_array.shape==pred_array.shape, \
                (true_array.shape, pred_array.shape)
    ps = {
            "true_linewidth":1, "pred_linewidth":1,
            "true_linestyle":"-", "pred_linestyle":"-", "main_title":"",
            "quad_titles":["", "", "", ""], "figsize":(12,12), "dpi":100,
            "yscale":"linear", "lines_rgb":None, "grid":False,
            }
    ps.update(plot_spec)
    seq_range = np.arange(pred_array.shape[1]) * pred_coarseness
    plt.clf()
    fig,ax = plt.subplots(2, 2)
    num_px = pred_array.shape[0]
    cm = matplotlib.cm.get_cmap("hsv", num_px)

    has_legend = False
    for n in range(4):
        i = n // 2
        j = n % 2
        ## If fewer than 4 features are included, stop plotting
        if pred_array.shape[-1]-1 < n:
            break
        for px in range(pred_array.shape[0]):
            if not ps.get("lines_rgb") is None:
                color_true = ps["lines_rgb"][px]
                color_pred = ps["lines_rgb"][px]
            else:
                color_true = ps.get("true_color", cm(px))
                color_pred = ps.get("pred_color", cm(px))


            if not true_array is None:
                tmp_ax_true, = ax[i,j].plot(
                        seq_range,
                        true_array[px,:,n],
                        color=color_true,
                        linewidth=ps.get("true_linewidth"),
                        alpha=ps.get("line_opacity"),
                        linestyle=ps.get("true_linestyle", "-")
                        )
            tmp_ax_pred, = ax[i,j].plot(
                    seq_range,
                    pred_array[px,:,n],
                    color=color_pred,
                    linewidth=ps.get("pred_linewidth"),
                    alpha=ps.get("line_opacity"),
                    linestyle=ps.get("pred_linestyle", "-")
                    )

            ## Add a legend if it is requested but hasn't been added yet
            if not has_legend and not ps.get("pred_legend_label") is None:
                if true_array is None:
                    fig_legend = fig.legend(
                            (tmp_ax_pred,),
                            (ps.get("pred_legend_label"),),
                            loc=ps.get("legend_location", "upper left")
                            )
                else:
                    fig_legend = fig.legend(
                            (tmp_ax_pred, tmp_ax_true),
                            (ps.get("pred_legend_label"),
                                ps.get("true_legend_label")),
                            loc=ps.get("legend_location", "upper left"),
                            prop={"size": ps.get("legend_size",12)},
                            )

            ax[i,j].set_title(ps["quad_titles"][n],
                    fontsize=ps.get("quad_title_size",12))
            if plot_spec.get("yrange"):
                ax[i,j].set_ylim(plot_spec.get("yrange"))
            if plot_spec.get("xrange"):
                ax[i,j].set_xlim(plot_spec.get("xrange"))
            ax[i,j].set_xscale(plot_spec.get("xscale", "linear"))
            ax[i,j].set_yscale(plot_spec.get("yscale", "linear"))

    fig.supxlabel(plot_spec.get("xlabel"), fontsize=ps.get("xlabel_size", 16))
    fig.supylabel(plot_spec.get("ylabel"), fontsize=ps.get("ylabel_size", 16))

    if ps.get("grid"):
        plt.grid()
    if ps["main_title"] != "":
        fig.suptitle(ps["main_title"], fontsize=ps.get("main_title_size", 16))
    plt.tight_layout()
    if not fig_path is None:
        print(f"Saving {fig_path.as_posix()}")
        if ps.get("figsize"):
            fig.set_size_inches(*ps.get("figsize"))
        fig.savefig(fig_path.as_posix(), bbox_inches="tight",
                dpi=ps.get("dpi"))
    if show:
        plt.show()
    plt.close()
    return

def mp_plot_pred_ensembles(kwargs:dict):
    return plot_pred_ensembles(**kwargs)
def plot_pred_ensembles(subgrid_h5_path:Path, plot_feats:list, fig_dir:Path):
    """
    High-level method for plotting an entire subgrid's true, predicted,
    and error values as an ensemble of time series.
    """
    _,model_config,gen_args = parse_grid_params(subgrid_h5_path)
    file_feats = gen_args.get("pred_feats")
    feat_idxs = tuple(file_feats.index(s) for s in plot_feats)
    #p_mean,p_stdev = generators.get_dynamic_coeffs(file_feats)
    with h5py.File(subgrid_h5_path, mode="r") as tmp_h5:
        P = tmp_h5["/data/preds"][...]
        Y = tmp_h5["/data/truth"][...]
        S = tmp_h5["/data/static"][...]

    ## Get the soil percent indeces to assign RGB colors
    sfeats = gen_args["static_feats"]
    soil_feats = ("pct_sand", "pct_silt", "pct_clay")
    soil_idxs = tuple(sfeats.index(s) for s in soil_feats)
    #soil_mean,soil_stdev = generators.get_static_coeffs(soil_feats)
    soil_rgb = np.clip(S[...,soil_idxs], 0., 1.)
    #print(soil_rgb.shape, P.shape, Y.shape)

    plot_specs = (plot_spec_res_values.copy(), plot_spec_res_error.copy(),
            plot_spec_state_values.copy(), plot_spec_state_error.copy())

    ## Provide soil texture RGBs
    for ps in plot_specs:
        lines_rgb = ps.get("lines_rgb")
        if type(lines_rgb)==str and lines_rgb=="soil_texture":
            ps["lines_rgb"] = soil_rgb
        if "{subgrid_info}" in ps.get("xlabel",""):
            ps["xlabel"] = ps["xlabel"].replace(
                    "{subgrid_info}",
                    " ".join(subgrid_h5_path.stem.split("_")[1:])
                    )
        if "{subgrid_info}" in ps.get("main_title",""):
            ps["xlabel"] = ps["main_title"].replace(
                    "{subgrid_info}",
                    " ".join(subgrid_h5_path.stem.split("_")[1:])
                    )

    for sample_idx in range(P.shape[0]):
        pr = P[sample_idx,...,] # / p_stdev
        ys = Y[sample_idx,...]
        ps = ys[:,0,:][:,np.newaxis,:] + np.cumsum(pr, axis=1)
        yr = ys[:,1:]-ys[:,:-1]
        es = ps - ys[:,1:,:]
        er = pr - yr

        ## Plot residual values
        plot_quad_sequence(
                true_array=yr[...,feat_idxs],
                pred_array=pr[...,feat_idxs],
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_res-value.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[0],
                show=False,
                )

        ## Plot residual error
        plot_quad_sequence(
                pred_array=er,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_res-error.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[1],
                show=False,
                )

        ## Plot state values
        plot_quad_sequence(
                true_array=ys[:,1:,:],
                pred_array=ps,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_state-value.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[2],
                show=False,
                )

        ## Plot state error
        plot_quad_sequence(
                pred_array=es,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_state-error.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[3],
                show=False,
                )

if __name__=="__main__":
    subgrid_h5_dir = Path("data/subgrid_samples_bad/")
    fig_dir = Path("figures/subgrid_samples_bad")
    #plot_feats = ("soilm-10", "soilm-40", "soilm-100", "soilm-200")
    plot_feats = ("rsm-10", "rsm-40", "rsm-100")
    #plot_feats = ("rsm-fc",)

    #file_substrings = ["lstm-rsm-2", "lstm-rsm-3"]
    #file_substrings = ["lstm-rsm-4", "lstm-rsm-1"]
    #file_substrings = ["lstm-2"]
    file_substrings = [
            #"rsm-9", "rsm-10", "rsm-11",
            "rsm-8", "rsm-3",
            ]

    plot_spec_state_error = {
            #"main_title":"Error in volumetric soil mosisture",
            "main_title":"Error in relative soil moisture by soil texture",
            "quad_titles":plot_feats,
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Error in layer moisture content (kg/m^2)",
            "ylabel":"Error in layer relative moisture content (fraction)",
            "line_opacity":.3,
            "lines_rgb":"soil_texture",
            "true_linewidth":2,
            "pred_linewidth":2,
            "figsize":(11,7),
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Color from soil texture RGB",
            }
    plot_spec_res_error = {
            #"main_title":"Error in soil moisture residual",
            "main_title":"Error in residual RSM by soil texture",
            "quad_titles":plot_feats,
            #"yscale":"symlog",
            "yscale":"linear",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Error in layer residual (kg/(hr m^2))",
            "ylabel":"Error in RSM residual (fraction/hour)",
            "line_opacity":.3,
            "lines_rgb":"soil_texture",
            "true_linewidth":2,
            "pred_linewidth":2,
            "main_title_size":18,
            "figsize":(11,7),
            "legend_location":"lower left",
            "pred_legend_label":"Color from soil texture RGB",
            }
    plot_spec_state_values = {
            #"main_title":"Hourly volumetric soil mosisture",
            "main_title":"Hourly relative soil mosisture",
            "quad_titles":plot_feats,
            "true_color":"blue",
            "pred_color":"orange",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Layer moisture content (kg/m^2)",
            "ylabel":"Layer relative soil moisture (fraction)",
            "line_opacity":.4,
            "true_linestyle":"-",
            "pred_linestyle":"-",
            "true_linewidth":2,
            "pred_linewidth":2,
            "figsize":(11,7),
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Predicted State",
            "true_legend_label":"True State",
            }
    plot_spec_res_values = {
            #"main_title":"Hourly change in soil moisture area density",
            "main_title":"Hourly change in relative soil moisture",
            "quad_titles":plot_feats,
            #"yscale":"symlog",
            "yscale":"linear",
            "true_color":"blue",
            "pred_color":"orange",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Soil moisture layer residual kg/(hr m^2)",
            "ylabel":"Layer residual relative soil moisture (fraction/hour)",
            "line_opacity":.4,
            "true_linestyle":"-",
            "pred_linestyle":"-",
            "true_linewidth":2,
            "pred_linewidth":2,
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Predicted State",
            "true_legend_label":"True State",
            "figsize":(11,7),
            }

    num_workers = 10
    ppt(subgrid_h5_dir.iterdir())
    print(file_substrings)
    sg_files = [p for p in subgrid_h5_dir.iterdir()
            if any(s in p.name for s in file_substrings)]
    mp_args = [{
        "subgrid_h5_path":p,
        "fig_dir":fig_dir,
        "plot_feats":plot_feats,
        } for p in sg_files]
    with Pool(num_workers) as pool:
        pool.map(mp_plot_pred_ensembles, mp_args)
