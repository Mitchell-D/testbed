"""
High-level method for plotting ensembles of state and residual magnitude
and error from a directory of extracted grid prediction hdf5s, which
should have been generated by eval_subgrid_samples.py
"""
import numpy as np
import pickle as pkl
from datetime import datetime
from pathlib import Path
import matplotlib
import matplotlib.pyplot as plt
import h5py
from multiprocessing import Pool
from pprint import pprint as ppt

from testbed import generators
from testbed import eval_models
from testbed.plotting import plot_quad_sequence

def plot_state_and_res_mag_and_error(
        pred_array, true_array, fig_path=None, pred_coarseness=1,
        plot_spec={}, show=False):
    """ """
    assert true_array.shape==pred_array.shape, \
            (true_array.shape, pred_array.shape)
    ps.update(plot_spec)
    seq_range = np.arange(pred_array.shape[1]) * pred_coarseness
    plt.clf()
    fig,ax = plt.subplots(2, 2)
    num_px = pred_array.shape[0]
    cm = matplotlib.cm.get_cmap("hsv", num_px)

    ## plot state predictions and truth

    ## plot res predictions and truth

    ## plot state error rates

    ## plot res error rates
    pass

def mp_plot_pred_ensembles(kwargs:dict):
    return plot_pred_ensembles(**kwargs)
def plot_pred_ensembles(subgrid_h5_path:Path, plot_feats:list, fig_dir:Path):
    """
    High-level method for plotting an entire subgrid's true, predicted,
    and error values as an ensemble of time series.
    """
    _,model_config,gen_args = eval_models.parse_grid_params(subgrid_h5_path)
    file_feats = gen_args.get("pred_feats")
    feat_idxs = tuple(file_feats.index(s) for s in plot_feats)
    #p_mean,p_stdev = generators.get_dynamic_coeffs(file_feats)
    with h5py.File(subgrid_h5_path, mode="r") as tmp_h5:
        P = tmp_h5["/data/preds"][...]
        Y = tmp_h5["/data/truth"][...]
        S = tmp_h5["/data/static"][...]

    ## Get the soil percent indeces to assign RGB colors
    sfeats = gen_args["static_feats"]
    soil_feats = ("pct_sand", "pct_silt", "pct_clay")
    soil_idxs = tuple(sfeats.index(s) for s in soil_feats)
    #soil_mean,soil_stdev = generators.get_static_coeffs(soil_feats)
    soil_rgb = np.clip(S[...,soil_idxs], 0., 1.)
    #print(soil_rgb.shape, P.shape, Y.shape)

    plot_specs = (plot_spec_res_values.copy(), plot_spec_res_error.copy(),
            plot_spec_state_values.copy(), plot_spec_state_error.copy())

    ## Provide soil texture RGBs
    for ps in plot_specs:
        lines_rgb = ps.get("lines_rgb")
        if type(lines_rgb)==str and lines_rgb=="soil_texture":
            ps["lines_rgb"] = soil_rgb
        if "{subgrid_info}" in ps.get("xlabel",""):
            ps["xlabel"] = ps["xlabel"].replace(
                    "{subgrid_info}",
                    " ".join(subgrid_h5_path.stem.split("_")[1:])
                    )
        if "{subgrid_info}" in ps.get("main_title",""):
            ps["xlabel"] = ps["main_title"].replace(
                    "{subgrid_info}",
                    " ".join(subgrid_h5_path.stem.split("_")[1:])
                    )

    for sample_idx in range(P.shape[0]):
        pr = P[sample_idx,...,] # / p_stdev
        ys = Y[sample_idx,...]
        ps = ys[:,0,:][:,np.newaxis,:] + np.cumsum(pr, axis=1)
        yr = ys[:,1:]-ys[:,:-1]
        es = ps - ys[:,1:,:]
        er = pr - yr

        ## Plot residual values
        plot_quad_sequence(
                true_array=yr[...,feat_idxs],
                pred_array=pr[...,feat_idxs],
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_res-value.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[0],
                show=False,
                )

        ## Plot residual error
        plot_quad_sequence(
                pred_array=er,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_res-error.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[1],
                show=False,
                )

        ## Plot state values
        plot_quad_sequence(
                true_array=ys[:,1:,:],
                pred_array=ps,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_state-value.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[2],
                show=False,
                )

        ## Plot state error
        plot_quad_sequence(
                pred_array=es,
                fig_path=fig_dir.joinpath(
                    subgrid_h5_path.stem+"_state-error.png"),
                pred_coarseness=model_config["feats"]["pred_coarseness"],
                plot_spec=plot_specs[3],
                show=False,
                )

if __name__=="__main__":
    subgrid_h5_dir = Path("data/subgrid_samples_bad/")
    fig_dir = Path("figures/subgrid_samples_bad")
    #plot_feats = ("soilm-10", "soilm-40", "soilm-100", "soilm-200")
    plot_feats = ("rsm-10", "rsm-40", "rsm-100")
    #plot_feats = ("rsm-fc",)
    #plot_feats = ("tsoil-10", "tsoil-40", "tsoil-100")

    #file_substrings = ["lstm-rsm-2", "lstm-rsm-3"]
    #file_substrings = ["lstm-rsm-4", "lstm-rsm-1"]
    #file_substrings = ["lstm-2"]
    file_substrings = [
            #"rsm-9", "rsm-10", "rsm-11", #"rsm-8", "rsm-3", #"rsm-15",
            #"rsm-16",
            #"rsm-19",
            #"tsoil-1",
            "acclstm-rsm-12",
            ]

    plot_spec_state_error = {
            #"main_title":"Error in volumetric soil mosisture",
            "main_title":"Error in relative soil moisture by soil texture",
            #"main_title":"Error in soil temperature by soil texture",
            "quad_titles":plot_feats,
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Error in layer moisture content (kg/m^2)",
            "ylabel":"Error in layer relative moisture content (fraction)",
            #"ylabel":"Error in soil temperature (K)",
            "line_opacity":.3,
            "lines_rgb":"soil_texture",
            "true_linewidth":2,
            "pred_linewidth":2,
            "figsize":(11,7),
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Color from soil texture RGB",
            }
    plot_spec_res_error = {
            #"main_title":"Error in soil moisture residual",
            "main_title":"Error in residual RSM by soil texture",
            #"main_title":"Error in increment soil temperature by soil texture",
            "quad_titles":plot_feats,
            #"yscale":"symlog",
            "yscale":"linear",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Error in layer residual (kg/(hr m^2))",
            "ylabel":"Error in RSM residual (fraction/hour)",
            #"ylabel":"Error in increment soil temperature (k/hour)",
            "line_opacity":.3,
            "lines_rgb":"soil_texture",
            "true_linewidth":2,
            "pred_linewidth":2,
            "main_title_size":18,
            "figsize":(11,7),
            "legend_location":"lower left",
            "pred_legend_label":"Color from soil texture RGB",
            }
    plot_spec_state_values = {
            #"main_title":"Hourly volumetric soil mosisture",
            "main_title":"Hourly relative soil mosisture",
            #"main_title":"Hourly soil temperature",
            "quad_titles":plot_feats,
            "true_color":"blue",
            "pred_color":"orange",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Layer moisture content (kg/m^2)",
            "ylabel":"Layer relative soil moisture (fraction)",
            #"ylabel":"Layer soil temperature (K)",
            "line_opacity":.4,
            "true_linestyle":"-",
            "pred_linestyle":"-",
            "true_linewidth":2,
            "pred_linewidth":2,
            "figsize":(11,7),
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Predicted State",
            "true_legend_label":"True State",
            }
    plot_spec_res_values = {
            #"main_title":"Hourly change in soil moisture area density",
            "main_title":"Hourly change in relative soil moisture",
            #"main_title":"Hourly change in soil temperature",
            "quad_titles":plot_feats,
            #"yscale":"symlog",
            "yscale":"linear",
            "true_color":"blue",
            "pred_color":"orange",
            "xlabel":"Forecast hour \n {subgrid_info}",
            #"ylabel":"Soil moisture layer residual kg/(hr m^2)",
            "ylabel":"Layer residual relative soil moisture (fraction/hour)",
            #"ylabel":"Layer residual soil temperature (K/hour)",
            "line_opacity":.4,
            "true_linestyle":"-",
            "pred_linestyle":"-",
            "true_linewidth":2,
            "pred_linewidth":2,
            "main_title_size":18,
            "legend_location":"lower left",
            "pred_legend_label":"Predicted State",
            "true_legend_label":"True State",
            "figsize":(11,7),
            }

    num_workers = 10
    ppt(subgrid_h5_dir.iterdir())
    print(file_substrings)
    sg_files = [p for p in subgrid_h5_dir.iterdir()
            if any(s in p.name for s in file_substrings)]
    mp_args = [{
        "subgrid_h5_path":p,
        "fig_dir":fig_dir,
        "plot_feats":plot_feats,
        } for p in sg_files]
    with Pool(num_workers) as pool:
        pool.map(mp_plot_pred_ensembles, mp_args)
